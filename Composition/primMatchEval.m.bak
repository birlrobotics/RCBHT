%%************************ Documentation **********************************
% After finding any of the 8 labels: bpos,mpos,spos,bneg,mneg,snet,const,impulse
% Determine if the index+window range has one of following outcomes, and
% assign an appropriate action to the combination:
%   Positive
%       Neg:    adjustment, 'a'
%       Pos:    increase,   'i'
%       Const:  increase,   'i'
%   Negative
%       Pos:    adjustment, 'a'
%       Neg:    decrease,   'd'
%       Const:  decrease,   'd'
%   Constant
%       Pos:    increase,   'i'
%       Neg:    decrease,   'd'
%       Const:  constant,   'k'
%   Pimp
%       Pos:    unstable,   'u'
%       Neg:    contact,    'c'
%       Const:  unstable,   'u'
%       Nimp:   adjustment, 'a'
%
%   Nimp
%       Pos:    contact,    'c'
%       Neg:    unstable,   'u'
%       Const:  unstable,   'u'
%       Pimp:   adjustment, 'a'
%
% Input Parameters:     
%
% index:                    - indicates what primitive segment we are on
% labelType:                - string describing whether 'positive','negative,'constant','impulse'
% szLabel:                  - CELL string array. Indicates whether prim is b/m/s/pos/net/const/impulse/
%
% motComps(motCompsIndex)   - a 1x11 dimensional struc to hold composite primitives info
%                           - [actnClass,avgMagVal,rmsVal,glabel1,glabel2,t1Start,t1End,t2Start,t2End,tAvgIndex]
%                           - defined in CompoundMotionComposition.m
%                           - Usually extract values from:
%                             statData[avg,max,min,start_time,finish_time,gradient,gradientlbl]. 
%
% gradLabels                - gradient label classification structure,
%                             originally defined in fitRegressionCurves.m 
%                             Using the same struc throught all the m files
%                             helps to insure there is consistency across
%                             function calls
%**************************************************************************
function [motComps index]=primMatchEval(index,labelType,lbl,statData,gradLabels)
    
%% Initialization    
    [r c]           = size(statData);               % rows and columns of statData
    
    % Set the range by looking at a window after the index
    window              = 0;                        % Look for pattern within this window of primitive motion segments segments
    if(index+window<r)
        nextIndex       = index+1;                  % Index indicating start of window range after first primitive found
        Range           = nextIndex+window;         % Index indicating last element of window range        
    elseif(index+window<r+window)                   % This is one before the last iteration
        nextIndex       = index+1;
        Range           = nextIndex+(r-index-1);    % This equation appropriately sets the val of Range independent of window size
    elseif(index+window==r+window)                  % This is the last iteration
        nextIndex       = index;
        Range           = index;
    else                                            % This is when the indeces have been exceeded
        % Return empty info
        motComps={[],[],[],[],[],[],[],[],[]};
        index = r+1;        
        return;     % maximum index has been passed. do nothing and return 
    end
    
    % CONSTANTS FOR gradLabels (defined in fitRegressionCurves.m)
    BPOS            = 1;        % big   pos gradient
    MPOS            = 2;        % med   pos gradient
    SPOS            = 3;        % small pos gradient
    BNEG            = 4;        % big   neg gradient
    MNEG            = 5;        % med   neg gradient
    SNEG            = 6;        % small neg gradient
    CONST           = 7;        % constant  gradient
    PIMP            = 8;        % large pos gradient 
    NIMP            = 9;        % large neg gradient
    NONE            = 10;       % none
    
%%  DEFINE ACTION CLASS    
    % String Cell Array used to describe the kind of action (a=adjustment, i=increase, d=decrease, c=constant).
    actnClass       = '';
    
    % These variables are used for indexing actnClassLbl. 
    adjustment      = 1;    % a
    increase        = 2;    % i
    decrease        = 3;    % d
    constant        = 4;    % k
    contact         = 5;    % c
    unstable        = 6;    % u
    classLbl        = {'a','i','d','k','c','u'};  % String representation of each possibility in the actnClass set.                 
    
    noMatch         = false;                      % Flag used when primitives repeat
%%  MATCHES
    % statData{m,[Avg,Max,Min,Start,Finish,gradient,label]} 
    % Pending.... For now, we will only look for direct connections:
    % i.e. bpos and bneg. Not for bpos/mneg, bpos/sneg

%% POSITIVE LABELS
    if(strcmp(labelType,'positive'))

        % Examine the window range
        for match=nextIndex:Range            

%%          POSITIVE LABEL folled by NEGATIVE LABEL = MATCH = ALIGNMENT
            if(strcmp(statData{match,7}, gradLabels{BNEG}) || ...     %bneg
                    strcmp(statData{match,7}, gradLabels{MNEG}) || ...%mneg
                        strcmp(statData{match,7}, gradLabels{SNEG}))  %sneg. match is the index that looks ahead.                                                                 
                    
                % Set the type of the second label
                if(strcmp(statData{match,7}, gradLabels{BNEG}))    
                    lbl2=BNEG;
                    noMatch = false;
                elseif(strcmp(statData{match,7}, gradLabels{MNEG}))
                    lbl2=MNEG;
                    noMatch = false;
                elseif(strcmp(statData{match,7}, gradLabels{SNEG}))
                    lbl2=SNEG;
                    noMatch = false;
                else
                    noMatch = true;
                end
                
                % If we have a match
                if(~noMatch)
                    % Class: adjustment
                    actnClass = classLbl{1,adjustment};

                    % amplitudeVal: maxp1,minp2
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('pos','neg',p1,p2);

                    % Gradient labels
                    glabel1 = gradLabels{lbl};
                    glabel2 = gradLabels{lbl2};    
                end                
                break;

%%          POSITIVE LABEL follwed by POSITIVE LABEL = REPEAT = INCREASE
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{BPOS}) || ...     % bpos
                        strcmp(statData{match,7}, gradLabels{MPOS}) || ...% mpos
                            strcmp(statData{match,7}, gradLabels{SPOS}))  % spos. match is the index that looks ahead. 

                % Set the type of the second label
                if(strcmp(statData{match,7}, gradLabels{BPOS}))    
                    lbl2=BPOS;
                    noMatch = false;
                elseif(strcmp(statData{match,7}, gradLabels{MPOS}))
                    lbl2=MPOS;
                    noMatch = false;
                elseif(strcmp(statData{match,7}, gradLabels{SPOS}))
                    lbl2=SPOS;
                    noMatch = false;
                else
                    noMatch = true;
                end                        
                        
                % If no matching negative label, then we have a pure increase in the gradient
                if(~noMatch)                 % The structure of the flag condition assumes window is length 2.
                    % actnClass: increase
                    actnClass = classLbl{1,increase};     % Increase

                    % amplitudeVal: maxp2,minp1
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('pos','pos',p1,p2);
                
                    % Gradient labels
                    glabel1 = gradLabels{lbl};     % Positive
                    glabel2 = gradLabels{lbl2};    % Positive
                end
                break;
%%          POSITIVE LABEL followed by CONSTANT LABEL = INCREASE
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{CONST}))  % match is the index that looks ahead. 

                % If no matching negative label, then we have a pure increase in the gradient
                if(noMatch)% Class
                    actnClass = classLbl{1,increase};                 
                
                    % amplitudeVal: maxp2,minp1
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('pos','const',p1,p2);
                                    
                    % Gradient labels
                    glabel1 = gradLabels{lbl};              % Positive
                    glabel2 = gradLabels{CONST};            % Constant
                    
                    break;

                % Repeat, try again
                else
                    noMatch = true;                      % If primitive repeats, don't do anything. Change flag, in case a repeat takes place.                    
                end                
                  
%%          POSITIVE LABEL followed by PIMP = CONTACT
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{PIMP}))  % match is the index that looks ahead. 

                % If no matching negative label, then we have a pure increase in the gradient
                if(noMatch)% Class
                    actnClass = classLbl{1,contact};                % contact               
                
                    % amplitudeVal: maxp2,minp1
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('pos','pos',p1,p2);
                                    
                    % Gradient labels
                    glabel1 = gradLabels{lbl};             % Positive
                    glabel2 = gradLabels{PIMP};            % Pimp
                    
                    break;

                % Repeat, try again
                else
                    noMatch = true;                      % If primitive repeats, don't do anything. Change flag, in case a repeat takes place.                    
                end
                
%%          POSITIVE LABEL followed by NIMP = CONTACT
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{NIMP}))  % match is the index that looks ahead. 

                % If no matching negative label, then we have a pure increase in the gradient
                if(noMatch)% Class
                    actnClass = classLbl{1,contact};                % contact               
                
                    % amplitudeVal: maxp2,minp1
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('pos','neg',p1,p2);
                                    
                    % Gradient labels
                    glabel1 = gradLabels{lbl};             % Positive
                    glabel2 = gradLabels{NIMP};            % Nimp
                    
                    break;

                % Repeat, try again
                else
                    noMatch = true;                      % If primitive repeats, don't do anything. Change flag, in case a repeat takes place.                    
                end 
                
%%          NONE
            else
                actnClass   = 'i';                     % increase
                amplitudeVal = computedAmplitude('pos','pos',p1,p2)
                glabel1 = gradLabels{lbl};             % positive
                glabel2 = gradLabels{MPOS};            % positive
                
                break;
                
            end % End combinations
        end     % End match

%% IF NEGATIVE
    elseif(strcmp(labelType,'negative'))
        
        % Examine the window range
        for match=nextIndex:Range            

%%          NEGATIVE LABEL followed by POSITIVE LABELS = MATCH = ALIGNMENT
            if(strcmp(statData{match,7}, gradLabels{BPOS}) || ...     %bpos
                    strcmp(statData{match,7}, gradLabels{MPOS}) || ...%mpos
                        strcmp(statData{match,7}, gradLabels{SPOS}))  %spos.match is the index that looks ahead.                                                                 
                
                % Set the type of the second label
                if(strcmp(statData{match,7}, gradLabels{BPOS}))    lbl2=BPOS;
                elseif(strcmp(statData{match,7}, gradLabels{MPOS}))lbl2=MPOS;
                else                                               lbl2=SPOS;
                end
                
                % Class
                actnClass = classLbl{1,adjustment};                            % Alignment
                    
                % amplitudeVal: maxp2,minp1
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('neg','pos',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{lbl};
                glabel2 = gradLabels{lbl2};         
                
                break;

%%          NEGATIVE LABEL followed by NEGATIVE LABELS = REPEAT = DECREASE
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{BNEG}) || ...
                        strcmp(statData{match,7}, gradLabels{MNEG}) || ...
                            strcmp(statData{match,7}, gradLabels{SNEG}))  % match is the index that looks ahead. 
                        
                % Set the type of the second label
                if(strcmp(statData{match,7}, gradLabels{BNEG}))    
                    lbl2=BNEG;
                    noMatch = false;
                elseif(strcmp(statData{match,7}, gradLabels{MNEG}))
                    lbl2=MNEG;
                    noMatch = false;
                elseif(strcmp(statData{match,7}, gradLabels{SNEG}))
                    lbl2=SNEG;
                    noMatch = false;
                else
                    noMatch = true;
                end
                
                % If no matching NEGATIVE label, then we have a single decrease in the gradient
                if(~noMatch)                             % The structure of the flag condition assumes window is length 2.
                    actnClass = classLbl{1,decrease};    % Decrease

                    % amplitudeVal: maxp1,minp1
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('neg','neg',p1,p2);
                
                                        
                    % Gradient labels
                    glabel1 = gradLabels{lbl};     % Negative
                    glabel2 = gradLabels{lbl2};    % Negative
                    
                    break;
                end
%%          NEGATIVE LABEL followed by CONSTANT LABEL = DECREASE
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{CONST}))        % match is the index that looks ahead. 

                % If no matching negative label, then we have a pure increase in the gradient
                if(noMatch)                                             % The structure of the flag condition assumes window is length 2.
                    actnClass = classLbl{1,decrease};                 
                 
                    % amplitudeVal: minp1,maxp2
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('neg','const',p1,p2);                   
                    
                    % Gradient labels
                    glabel1 = gradLabels{lbl};              % Negative
                    glabel2 = gradLabels{CONST};            % Constant
                    
                    break;

                % Repeat, try again
                else
                    noMatch = true;                      % If primitive repeats, don't do anything. Change flag, in case a repeat takes place.                    
                end                
 
%%          NEGATIVE LABEL followed by PIMP = CONTACT
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{PIMP}))  % match is the index that looks ahead. 

                % If no matching negative label, then we have a pure increase in the gradient
                if(noMatch)% Class
                    actnClass = classLbl{1,contact};                % contact               
                
                    % amplitudeVal: maxp2,minp1
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('neg','pos',p1,p2);
                                    
                    % Gradient labels
                    glabel1 = gradLabels{lbl};             % Negative
                    glabel2 = gradLabels{PIMP};            % Pimp
                    
                    break;

                % Repeat, try again
                else
                    noMatch = true;                      % If primitive repeats, don't do anything. Change flag, in case a repeat takes place.                    
                end
                
%%          NEGATIVE LABEL followed by NIMP = CONTACT
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{NIMP}))  % match is the index that looks ahead. 

                % If no matching negative label, then we have a pure increase in the gradient
                if(noMatch)% Class
                    actnClass = classLbl{1,contact};                % contact               
                
                    % amplitudeVal: maxp2,minp1
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('neg','neg',p1,p2);
                                    
                    % Gradient labels
                    glabel1 = gradLabels{lbl};             % Positive
                    glabel2 = gradLabels{NIMP};            % Nimp
                    
                    break;

                % Repeat, try again
                else
                    noMatch = true;                      % If primitive repeats, don't do anything. Change flag, in case a repeat takes place.                    
                end 
                                
                
%%          NONE
            else
                actnClass   = 'none';
                glabel1 = gradLabels{lbl};             % constant
                glabel2 = gradLabels{NONE};            % none
                
            end % End combinations
        end     % End match
%% IF CONSTANT: only looks at the next index
    elseif(strcmp(labelType,'constant'))
        
        % Examine the nextIndex only
        for match=nextIndex:nextIndex+1            

%%          CONSTANT WITH INCREASE
            if(strcmp(statData{match,7}, gradLabels{BPOS}) || ...
                    strcmp(statData{match,7}, gradLabels{MPOS}) || ...
                        strcmp(statData{match,7}, gradLabels{SPOS}))            % CONSTANT + POSITIVE
                                                                            
                % Class
                actnClass = classLbl{1,increase};                               % Increase

                % amplitudeVal: minp1,maxp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('const','pos',p1,p2);
                    
                % Gradient labels
                glabel1 = gradLabels{CONST};
                glabel2 = gradLabels{MPOS};                           % Positive. Have not refined the exact dimension here.
                
                break;

%%          CONSTANT WITH DECREASE
            elseif(strcmp(statData{match,7}, gradLabels{BNEG}) || ...
                    strcmp(statData{match,7}, gradLabels{MNEG}) || ...
                        strcmp(statData{match,7}, gradLabels{SNEG}))        % CONSTANT + NEGATIVE
               
                % Class: decrease
                actnClass = classLbl{1,decrease};                             % Decrease

                % amplitudeVal: maxp1,minp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('const','neg',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{CONST};                    % Constant
                glabel2 = gradLabels{MNEG};                     % Negative. % Have not refined the exact dimension here
                
                break;
                
%%          CONSTANT WITH CONSTANT
            elseif(strcmp(statData{match,7}, gradLabels{CONST}))  % match is the index that looks ahead. 
              
                % Class
                actnClass = classLbl{1,constant};                   % CONSTANT

                % amplitudeVal: maxp1 - minp1
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('const','const',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{CONST};                       % Constant
                glabel2 = gradLabels{CONST};                       % Constant. % Have not refined the exact dimension here
                
                break;           

%%          CONSTANT LABEL followed by PIMP = CONTACT
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{PIMP}))  % match is the index that looks ahead. 

                % If no matching negative label, then we have a pure increase in the gradient
                if(noMatch)% Class
                    actnClass = classLbl{1,contact};                % contact               
                
                    % amplitudeVal: maxp2,minp1
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('const','pos',p1,p2);
                                    
                    % Gradient labels
                    glabel1 = gradLabels{lbl};             % Constant
                    glabel2 = gradLabels{PIMP};            % Pimp
                    
                    break;

                % Repeat, try again
                else
                    noMatch = true;                      % If primitive repeats, don't do anything. Change flag, in case a repeat takes place.                    
                end
                
%%          CONSTANT LABEL followed by NIMP = CONTACT
            %  Need a flag to see if we get constant repeat or a single
            %  case for the length of the window
            elseif(strcmp(statData{match,7}, gradLabels{NIMP}))  % match is the index that looks ahead. 

                % If no matching negative label, then we have a pure increase in the gradient
                if(noMatch)% Class
                    actnClass = classLbl{1,contact};                % contact               
                
                    % amplitudeVal: maxp2,minp1
                    % Max and min values of first and second primitives
                    p1max = statData{index,2}; p1min = statData{index,3};
                    p2max = statData{match,2}; p2min = statData{match,3}; 
                    p1 = [p1max p1min]; p2 = [p2max p2min];                
                    amplitudeVal = computedAmplitude('const','neg',p1,p2);
                                    
                    % Gradient labels
                    glabel1 = gradLabels{lbl};             % Constant
                    glabel2 = gradLabels{NIMP};            % Nimp
                    
                    break;

                % Repeat, try again
                else
                    noMatch = true;                      % If primitive repeats, don't do anything. Change flag, in case a repeat takes place.                    
                end 
                                
                
%%          NONE
            else
                actnClass       = 'none';
                amplitudeVal    = 0;
                glabel1         = gradLabels{lbl};             % constant
                glabel2         = gradLabels{NONE};            % none
                
                break;

            end % End combinations
        end     % End match

%% IF PIMP: only looks at the next index
    elseif(strcmp(labelType,'pimp'))    

        % Examine the window range
        for match=nextIndex:nextIndex+1            

%%          Positive impulse with positive = UNSTABLE
            if(strcmp(statData{match,7}, gradLabels{BPOS}) || ...
                    strcmp(statData{match,7}, gradLabels{MPOS}) || ...
                        strcmp(statData{match,7}, gradLabels{SPOS}) || ...
                            strcmp(statData{match,7}, gradLabels{PIMP}))  	% PIMP + POSITIVE
                                                                    
                % Class
                actnClass = classLbl{1,unstable};                           % unstable

                % amplitudeVal: minp1,maxp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('pos','pos',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{PIMP};                               % Impulse
                glabel2 = gradLabels{MPOS};                               % Increase. Have not refined the exact dimension here.
                
                break;

%%          IF POSITIVE IMPULSE WITH NEG GRADIENT = CONTACT
            elseif(strcmp(statData{match,7}, gradLabels{BNEG}) || ...
                    strcmp(statData{match,7}, gradLabels{MNEG}) || ...
                        strcmp(statData{match,7}, gradLabels{SNEG}))        % IMPULSE + NEGATIVE
               
                % Class
                actnClass = classLbl{1,contact};                              % Contact
                
                % amplitudeVal: maxp1,minp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('pos','neg',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{PIMP};                             % POSITIVE IMPULSE
                glabel2 = gradLabels{MNEG};                             % Decrease. % Have not refined the exact dimension here
                
                break;
                
                
%%          POSITIVE IMPULSE WITH CONSTANT = UNSTABLE
            elseif(strcmp(statData{match,7}, gradLabels{CONST}))  % match is the index that looks ahead. 
              
                % Class
                actnClass = classLbl{1,unstable};                          % unstable

                % amplitudeVal: maxp1,minp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('pos','const',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{PIMP};                 % Pimp
                glabel2 = gradLabels{CONST};                % Constant
                
                break;
            
%%          PIMP WITH NIMP = ADJUSTMENT
            elseif(strcmp(statData{match,7}, gradLabels{NIMP}))  % match is the index that looks ahead. 
                
                % Class
                actnClass = classLbl{1,adjustment};                     % adjustment

                % amplitudeVal: minp1,maxp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('pos','neg',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{PIMP};     % impulse
                glabel2 = gradLabels{NIMP};     % impulse
                
                break;

%%          NONE
            else
                actnClass       = 'none';
                amplitudeVal    = 0;
                glabel1         = gradLabels{lbl};             % constant
                glabel2         = gradLabels{NONE};            % none
                
                break;

            end % End combinations
        end     % End match
        
        
%% IF NIMP: only looks at the next index
    elseif(strcmp(labelType,'nimp'))    

        % Examine the window range
        for match=nextIndex:nextIndex+1            

%%          NEGATIVE IMPULSE WITH POSITIVE = CONTACT
            if(strcmp(statData{match,7}, gradLabels{BPOS}) || ...
                    strcmp(statData{match,7}, gradLabels{MPOS}) || ...
                        strcmp(statData{match,7}, gradLabels{SPOS}))  	% NIMP + pos
                                                                    
                % Class
                actnClass = classLbl{1,contact};                      	% contact

                % amplitudeVal: minp1,maxp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('neg','pos',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{NIMP};                               % Neg. Impulse
                glabel2 = gradLabels{MPOS};                               % Increase. Have not refined the exact dimension here.
                
                break;

%%          IF NEGATIVE IMPULSE WITH NEG GRADIENT = UNSTABLE
            elseif(strcmp(statData{match,7}, gradLabels{BNEG}) || ...
                    strcmp(statData{match,7}, gradLabels{MNEG}) || ...
                        strcmp(statData{match,7}, gradLabels{SNEG}))        % NIMP + NEGATIVE
               
                % Class
                actnClass = classLbl{1,unstable};                            % unstable
                
                % amplitudeVal: maxp1,minp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('neg','neg',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{NIMP};                             % NEGATIVE IMPULSE
                glabel2 = gradLabels{MNEG};                             % Decrease. % Have not refined the exact dimension here
                
                break;
                
                
%%          NIMP WITH CONSTANT = UNSTABLE
            elseif(strcmp(statData{match,7}, gradLabels{CONST}))  % match is the index that looks ahead. 
              
                % Class
                actnClass = classLbl{1,unstable};                          % unstable

                % amplitudeVal: maxp1,minp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('neg','const',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{NIMP};                 % Pimp
                glabel2 = gradLabels{CONST};                % Constant
                
                break;
            
%%          NIMP WITH PIMP = ADJUSTMENT
            elseif(strcmp(statData{match,7}, gradLabels{PIMP}))  % match is the index that looks ahead. 
                
                % Class
                actnClass = classLbl{1,adjustment};                     % adjustment

                % amplitudeVal: minp1,maxp2
                % Max and min values of first and second primitives
                p1max = statData{index,2}; p1min = statData{index,3};
                p2max = statData{match,2}; p2min = statData{match,3}; 
                p1 = [p1max p1min]; p2 = [p2max p2min];                
                amplitudeVal = computedAmplitude('neg','pos',p1,p2);
                
                % Gradient labels
                glabel1 = gradLabels{NIMP};     % impulse
                glabel2 = gradLabels{PIMP};     % impulse
                
                break;

%%          NONE
            else
                actnClass       = 'none';
                amplitudeVal    = 0;
                glabel1         = gradLabels{lbl};             % constant
                glabel2         = gradLabels{NONE};            % none
                
                break;

            end % End combinations
        end     % End match        
    end         % IF positive/negative/constant/impulse

%% Compute values, time indeces, and return the motComps structure    
    % Average magnitude value 
    avgMagVal = (statData{index,1}+statData{match,1})/2;   

    % Root mean square
    rmsVal = sqrt((statData{index,1}^2 + statData{match,1}^2)/2);

    % Compute time indeces
    t1Start = statData{index,4};             % Starting time for primitive 1
    t1End   = statData{index,5}-0.001;       % Ending time for primitive 1

    % Indeces Check: ensure no array is exceeded by the index
    if(match+1<r)                            
        t2Start = statData{match,4};         % Starting time for primitive 2
        t2End   = statData{match+1,5}-0.001; % Ending time for primitive 2
    else
        t2Start = statData{match,4};         % Starting time for primitive 2
        t2End   = statData{match,4};       % We are in the last element
    end
    
    tAvgIndex = (t1Start+t2End)/2;

    % Enter the following data into the motComps structure:
    motComps={actnClass,...          % type of motion actnClass: "adjustment", "constant", or "impulse". 
              avgMagVal,...          % Magnitude of data (average value). Needs to be averaged when second match is found
              rmsVal,...             % Root mean square value
              amplitudeVal,...       % Largest difference from one edge of p1 to the other edge of p2              
              glabel1,...            % bpos...snet...impulse
              glabel2,...            % type of label b/m/s/pos/neg/const/impulse
              t1Start,...            % time at which first primitive starts
              t1End,...              % time at which first primitive ends
              t2Start,...            % time at which second primitive starts
              t2End,...              % time at which second primitive ends
              tAvgIndex              % Avg time
              };                     % [actnClass,avgMagVal,rmsVal,glabel1,glabel2,t1Start,t1End,t2Start,t2End,tAvgIndex]

    % Update index
    index = match+1;      
    
end